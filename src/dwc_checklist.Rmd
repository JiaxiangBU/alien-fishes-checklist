---
title: "Darwin Core mapping"
subtitle: "For dataset: Checklist of alien fishes in Flanders, Belgium"
author:
- Lien Reyserhove
- Dimitri Brosens
- Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

This document describes how we map the checklist data to Darwin Core.

# Setup

```{r, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Set locale (so we use UTF-8 character encoding):

```{r, eval = F}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse) # For data transformations

# None core tidyverse packages:
library(magrittr)  # For %<>% pipes

# Other packages
library(janitor)   # For cleaning input data
library(readxl)    # To read excel files
library(stringr)   # to perform string operations
library(digest)    # To generate es
```

Set file paths (all paths should be relative to this script):
 
```{r}
# Raw files:
raw_data_file = "../data/raw/ExotischeVissenVlaanderen2016.xlsx"

# Processed files:
dwc_taxon_file = "../data/processed/taxon.csv"
dwc_vernacular_file = "../data/processed/vernacular_names.csv"
dwc_distribution_file = "../data/processed/distribution.csv"
```

# Read data

```{r}
# Read the source data:
raw_data <- read_excel(raw_data_file, sheet = "Checklist", na = "NA") 

# Clean the data somewhat: remove empty rows if present
raw_data %<>%
  remove_empty_rows() %>%     # Remove empty rows
  clean_names()               # Have sensible (lowercase) column names
```

We need to integrate the DwC term `taxonID` in each of the generated files (Taxon Core and extensions).
For this reason, it is easier to to generate this  `taxonID` here in our raw file. 

```{r}
# Vectorize the digest function (The digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

# Generate taxonID:
raw_data %<>% mutate (taxonID = paste("alien-fishes:taxon:", vdigest (latin_name, algo="md5"), sep=""))
```

Further processing:

```{r}
# Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:
colnames(raw_data) <- paste0("raw_", colnames(raw_data))

# Save those column names as a vector (makes it easier to remove them all later):
raw_colnames <- colnames(raw_data)
```
 
Preview data:

```{r}
head(raw_data)
```

# Create taxon core

```{r}
taxon <- raw_data
```

## Pre-processing
## Term mapping
 
Map the source data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml):
 
### language

```{r}
taxon %<>% mutate(language = "en")
```

### license

```{r}
taxon %<>% mutate(license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "Research Institute for Nature and Forest (INBO)")

```

### accessRights

```{r}
taxon %<>% mutate(accessRights = "http://www.inbo.be/en/norms-for-data-use")
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "Checklist of alien fishes in Flanders, Belgium")
```

### taxonID

```{r}
taxon %<>% mutate(taxonID = raw_taxonID)
```

### scientificName

```{r}
taxon %<>% mutate (scientificName = raw_latin_name)
```

### kingdom

```{r}
taxon %<>% mutate (kingdom = "Animalia")
```

### taxonRank

```{r}
taxon %<>% mutate (taxonRank = "species")
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(nomenclaturalCode = "ICZN")
```

## Post-processing

```{r}
# Remove the original columns:
taxon %<>% select(-one_of(raw_colnames))

# Preview data:
head(taxon)

# Save to CSV:
write.csv(taxon, file = dwc_taxon_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create Vernacular names extension

## Pre-processing:
```{r}
vernacular_names <- raw_data
```

## Term mapping

Map the source data to [Vernacular Names](http://rs.gbif.org/extension/gbif/1.0/vernacularname.xml):

### taxonID

```{r}
vernacular_names %<>% mutate(taxonID = raw_taxonID)
```

Vernacular names are available in two languages: English (`raw_common_name`) and Dutch (`raw_nederlandse_naam`). We will create two new columns `English` en `Dutch`, containing their respective vernacular names. We will then gather() these columns to generate one column containing all vernacularnames, linked with one column refering to the specific language.

### vernacularName

```{r}
# Create two new columns `English`and `Dutch`:
vernacular_names %<>% 
  mutate(English = raw_common_name) %<>%
  mutate(Dutch   = raw_nederlandse_naam)

# Gather these columns to generate `vernaculernamte`and `language`
vernacular_names %<>% gather(key, value, Dutch, English, na.rm = TRUE, convert = TRUE) %<>% 
  arrange(taxonID) %<>% # sort on taxonID
  select(raw_colnames, taxonID, value, key) %<>% # rearrange
  rename(vernacularNames = value)
```

### language

The column `key` generated for `vernacularNames` contains the information needed for `language`

```{r}
vernacular_names %<>% rename (language = key)
```

## Post-processing:

```{r}
# Remove the original columns:
vernacular_names %<>% select(-one_of(raw_colnames))

# Preview data:
head(vernacular_names)

# Save to CSV:
write.csv(vernacular_names, file = dwc_vernacular_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```


# Create Distribution Extension
  
## Pre-processing

```{r}
distribution <- raw_data
```

## Term mapping

### taxonID

```{r}
distribution %<>% mutate (taxonID = raw_taxonID)
```

### locationID

```{r}
distribution %<>% mutate(locationID = "ISO_3166-2:BE-VLG")
```

### locality

```{r}
distribution %<>% mutate(locality = "Flemish Region")
```

### countryCode

```{r}
distribution %<>% mutate(countryCode = "BE")
```

### occurrenceStatus

The content for `occurrenceStatus` can be found in `raw_status`.

```{r}
distribution %<>% mutate (occurrenceStatus = raw_status)
```

This needs some further processing. 

### establishmentMeans

Information for `establishmentMeans`can be found in `raw_pathway_s`, which contains a list of introduction pathways. We'll separate, clean, map and combine these values.  

First, we create a new column `pathway`based on `raw_pathway_s`

```{r}
distribution %<>% mutate(pathway = raw_pathway_s)
```

We separate `pathway` in two separte columns:

```{r}
distribution %<>% separate(
  pathway,
  into = c("pathway_1", "pathway_2"),
  sep = ", ",
  remove = TRUE,
  convert = FALSE,
  extra = "merge",
  fill = "right"
)
```

Gather pathways in a key and value column:

```{r}
distribution %<>% gather(
  key, value,
  pathway_1, pathway_2,
  na.rm = TRUE, # Also removes records for which there is no pathway_1
  convert = FALSE
)

```

Sort on `taxonID` to see pathways in context for each record:

```{r}
distribution %<>% arrange(taxonID)
```

Show unique values:

```{r}
distribution %>%
  distinct(value) %>%
  arrange(value)
```

```{r}
distribution %<>% mutate(mapped_value = recode(value,
    "AM" = "Active Migration",
    "AN" = "Angling/bait fish",
    "AQ" = "Aquaculture",
    "BC" = "Biological control",
    "BW" = "Ballast Water",
    "OR" = "Ornamental",
    "UN" = "Unintentional"))
```

Show mapped values:

```{r}
distribution %>%
  select(value, mapped_value) %>%
  group_by(value, mapped_value) %>%
  summarize(records = n()) %>%
  arrange(value) 
```

Drop value column:

```{r}
distribution %<>% select(-value)
```

Since our pathway controlled vocabulary is not allowed by GBIF in establishmentMeans (see [this link](https://github.com/trias-project/alien-plants-belgium/issues/35)), we'll also add it to the Description extension. Rather than cleaning it all over again there, we save it here:

```{r}
pathway <- distribution %>% select(
    one_of(raw_colnames), # Add raw columns
    mapped_value)
```

Spread values back to columns:

```{r}
distribution %<>% spread(key, mapped_value)
```

Create establishmentMeans columns where these values are concatentated with |:

```{r}
distribution %<>% mutate(establishmentMeans = 
  paste(pathway_1, pathway_2, sep = " | ")              
)
```

Annoyingly the paste() function does not provide an rm.na parameter, so NA values will be included as | NA. We can strip those out like this:

```{r}
distribution %<>% mutate(
  establishmentMeans = str_replace_all(establishmentMeans, " \\| NA", ""), # Remove ' | NA'
  establishmentMeans = recode(establishmentMeans, "NA" = "") # Remove NA at start of string
)
```

### eventDate

eventDate will be of format `start_year`/`current_year` (yyyy/now).
Create `start_year`from `raw_introduction`

```{r}
distribution %<>% mutate (start_year = raw_introduction)
```

Clean values:

```{r}
# Some `start_year` values are ranges. We change these ranges to the first year for which an observation is plausible.
distribution %<>% mutate(start_year = recode(start_year,
    "20xx" = "2000",
    "17th c." = "1601",
    "1980s" = "1980",
    "13th c." = "1201")
    
)
```

Create `current_year`:

```{r}
distribution %<>% mutate (current_year = "now")
```

Create `eventDate`:

```{r}
distribution %<>% mutate (eventDate = paste (start_year, current_year, sep = "/"))
```

Compare formated dates with orginal dates in `raw_introduction`:

```{r}
distribution %>% 
  select (raw_introduction, eventDate)
```


## Post-processing

Remove the original columns:

```{r}
distribution %<>% select(-one_of(raw_colnames), 
                         -pathway_1, -pathway_2,
                         -start_year, -current_year)
```

Preview data:

```{r}
distribution %>% 
  head()
```

Save to .csv:

```{r}
write.csv(distribution, file = dwc_distribution_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```


